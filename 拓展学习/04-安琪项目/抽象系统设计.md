
# 数据表设计

## 抽奖按钮

功能描述（我）：

一个九宫格，中间为抽奖按钮，周围八个格子中分别展示了不同的奖品。现在，需要单独对此抽奖功能所使用的数据表进行设计，需要考虑的点如下：
- 奖品共有八个
- 奖品结果由系统生成随机数决定
- 每个奖品的获得概率不同
- 奖品得奖概率由管理员设置
- 奖品有两个状态：可抽和锁定
- 奖品有积分类，管理员可设置用户抽中后获得不同的积分，这种奖品大概两三个
- 锁定的奖品可由积分解锁
- 奖品数量有限，奖品余量显示与减少由其他接口提供

需要思考的设计：
1. 数据表需要几个？
2. 数据表如何设计？（字段、属性等）
3. 随机数如何生成以保证对齐不同奖品的获奖概率？
4. 奖品状态如何控制？




### 抽奖功能数据表设计方案

#### 1. 数据表数量设计
根据需求分析，建议设计2个核心数据表：
- `prize`（奖品信息表）：存储奖品的基础信息、概率、状态等核心数据
- `user_points`（用户积分表）：记录用户积分信息，用于解锁锁定奖品

#### 2. 数据表详细设计

**(1) 奖品信息表（prize）**

| 字段名 | 数据类型 | 说明 | 约束 |
|--------|----------|------|------|
| id | INT | 奖品唯一标识 | 主键，自增 |
| name | VARCHAR(100) | 奖品名称 | 非空 |
| description | TEXT | 奖品描述 | 可为空 |
| probability | DECIMAL(5,4) | 中奖概率 | 非空，范围0-1（如0.05表示5%） |
| status | TINYINT | 状态 | 非空，0-锁定，1-可抽 |
| points | INT | 抽中获得积分 | 默认为0，积分类奖品设置具体值 |
| unlock_points | INT | 解锁所需积分 | 默认为0，非锁定奖品设为0 |
| sort | INT | 九宫格位置排序 | 1-8，代表8个位置 |
| total_quantity | INT | 总数量 | 非空 |
| remaining_quantity | INT | 剩余数量 | 非空，与其他接口同步 |
| created_at | DATETIME | 创建时间 | 非空 |
| updated_at | DATETIME | 更新时间 | 非空 |
| is_deleted | TINYINT | 逻辑删除 | 0-未删除，1-已删除 |

**(2) 用户积分表（user_points）**

| 字段名 | 数据类型 | 说明 | 约束 |
|--------|----------|------|------|
| id | INT | 记录ID | 主键，自增 |
| user_id | INT | 用户ID | 非空，外键关联用户表 |
| points | INT | 剩余积分 | 非空，默认为0 |
| updated_at | DATETIME | 更新时间 | 非空 |

#### 3. 随机数生成与概率匹配方案

采用"概率区间法"实现不同概率的奖品分配：

1. **初始化概率区间**：
   - 从`prize`表查询所有`status=1`（可抽）且`remaining_quantity>0`的奖品
   - 计算概率总和，确保总和≤1（可预留一定概率作为"未中奖"）
   - 为每个奖品分配一个区间范围，例如：
     - 奖品A（概率0.2）→ [0, 0.2)
     - 奖品B（概率0.3）→ [0.2, 0.5)
     - 奖品C（概率0.5）→ [0.5, 1.0)

2. **生成随机数并匹配**：
   ```python
   import random
   
   def get_random_prize(available_prizes):
       # 计算概率区间
       intervals = []
       current = 0
       for prize in available_prizes:
           next_val = current + prize['probability']
           intervals.append({
               'prize_id': prize['id'],
               'start': current,
               'end': next_val
           })
           current = next_val
       
       # 生成0-1之间的随机数
       random_num = random.random()
       
       # 匹配对应的奖品
       for interval in intervals:
           if interval['start'] <= random_num < interval['end']:
               return interval['prize_id']
       
       return None  # 未中奖
   ```

3. **概率调整机制**：
   - 管理员可通过后台修改`prize`表的`probability`字段
   - 系统定期重新计算概率区间（或每次抽奖前动态计算）

#### 4. 奖品状态控制逻辑

1. **状态切换条件**：
   - 管理员可直接修改`status`字段切换状态
   - 用户消耗积分解锁：当用户积分≥`unlock_points`时，可调用接口将`status`从0改为1，同时扣除相应积分

2. **状态检查流程**：
   - 每次抽奖前检查奖品`status`是否为1且`remaining_quantity>0`
   - 锁定状态的奖品在前端显示锁定图标，并提示所需解锁积分
   - 积分类奖品抽中后，系统调用积分接口增加用户积分

3. **数据一致性保障**：
   - 奖品状态更新和积分操作需加事务处理
   - 高并发场景下可使用分布式锁防止超发或重复解锁

这种设计既满足了概率控制、状态管理、积分交互等核心需求，又保持了数据表结构的简洁性和可扩展性。